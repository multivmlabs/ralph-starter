/**
 * Batch Task Fetcher
 *
 * Fetches multiple tasks from GitHub/Linear for batch processing.
 * Uses WritableIntegration for bidirectional task management.
 */

import { execa } from 'execa';

import type { IntegrationOptions, WritableIntegration } from '../integrations/base.js';

/**
 * A task to be processed in auto mode
 */
export interface BatchTask {
  /** Unique identifier (issue number, ticket ID) */
  id: string;
  /** Task title */
  title: string;
  /** Full task description */
  description: string;
  /** Source integration */
  source: 'github' | 'linear';
  /** URL to the task */
  url: string;
  /** Priority (lower = higher priority) */
  priority?: number;
  /** Labels/tags */
  labels?: string[];
  /** Owner/repo for GitHub */
  project?: string;
}

/**
 * Options for fetching batch tasks
 */
export interface BatchFetchOptions {
  /** Source to fetch from */
  source: 'github' | 'linear';
  /** Project identifier */
  project?: string;
  /** Filter by label */
  label?: string;
  /** Maximum tasks to fetch */
  limit?: number;
  /** Status filter */
  status?: string;
}

/**
 * Get a WritableIntegration instance for the given source
 */
async function getIntegration(source: 'github' | 'linear'): Promise<WritableIntegration> {
  if (source === 'github') {
    const { GitHubIntegration } = await import('../integrations/github/source.js');
    return new GitHubIntegration();
  }
  const { LinearIntegration } = await import('../integrations/linear/source.js');
  return new LinearIntegration();
}

/**
 * Fetch multiple tasks from a source
 */
export async function fetchBatchTasks(options: BatchFetchOptions): Promise<BatchTask[]> {
  switch (options.source) {
    case 'github':
      return fetchGitHubTasks(options);
    case 'linear':
      return fetchLinearTasks(options);
    default:
      throw new Error(`Unsupported source: ${options.source}`);
  }
}

/**
 * Fetch tasks from GitHub issues
 */
async function fetchGitHubTasks(options: BatchFetchOptions): Promise<BatchTask[]> {
  if (!options.project) {
    throw new Error('Project (owner/repo) is required for GitHub');
  }

  const args = [
    'issue',
    'list',
    '-R',
    options.project,
    '--json',
    'number,title,body,labels,state,url',
    '--state',
    options.status || 'open',
    '--limit',
    String(options.limit || 10),
  ];

  if (options.label) {
    args.push('--label', options.label);
  }

  const result = await execa('gh', args);
  const issues = JSON.parse(result.stdout) as Array<{
    number: number;
    title: string;
    body?: string;
    labels?: Array<{ name: string }>;
    url: string;
  }>;

  return issues.map((issue) => ({
    id: String(issue.number),
    title: issue.title,
    description: issue.body || '',
    source: 'github' as const,
    url: issue.url,
    labels: issue.labels?.map((l) => l.name),
    project: options.project,
  }));
}

/**
 * Fetch tasks from Linear
 */
async function fetchLinearTasks(options: BatchFetchOptions): Promise<BatchTask[]> {
  // Use the WritableIntegration to list tasks via GraphQL
  try {
    const integration = await getIntegration('linear');
    const intOpts: IntegrationOptions = {
      project: options.project,
      label: options.label,
      status: options.status,
      limit: options.limit || 10,
    };

    const tasks = await integration.listTasks(intOpts);
    return tasks.map((t) => ({
      id: t.identifier,
      title: t.title,
      description: '',
      source: 'linear' as const,
      url: t.url,
      priority: t.priority,
      labels: t.labels,
      project: options.project,
    }));
  } catch {
    throw new Error('Linear not authenticated. Run: ralph-starter config set linear.apiKey <key>');
  }
}

/**
 * Claim a task (mark as in-progress)
 */
export async function claimTask(task: BatchTask): Promise<void> {
  try {
    const integration = await getIntegration(task.source);

    switch (task.source) {
      case 'github':
        // Add "in-progress" label
        await integration.updateTask(
          task.id,
          { labels: ['in-progress'] },
          { project: task.project }
        );
        break;
      case 'linear':
        // Update status to "In Progress"
        await integration.updateTask(task.id, { status: 'In Progress' }, { project: task.project });
        break;
    }
  } catch {
    // Non-critical â€” label/status might not exist
  }
}

/**
 * Mark a task as complete
 */
export async function completeTask(
  task: BatchTask,
  result: { success: boolean; prUrl?: string }
): Promise<void> {
  if (!result.success) return;

  try {
    const integration = await getIntegration(task.source);

    switch (task.source) {
      case 'github':
        // Add comment with PR link
        if (result.prUrl) {
          await integration.addComment(
            task.id,
            `Automated PR created: ${result.prUrl}\n\n*Generated by ralph-starter auto mode*`,
            { project: task.project }
          );
        }
        // Remove in-progress label
        try {
          await execa('gh', [
            'issue',
            'edit',
            task.id,
            '-R',
            task.project || '',
            '--remove-label',
            'in-progress',
          ]);
        } catch {
          // Label might not exist
        }
        break;
      case 'linear':
        await integration.closeTask(task.id, undefined, { project: task.project });
        break;
    }
  } catch {
    // Non-critical
  }
}

/**
 * Skip a task (mark as skipped/blocked)
 */
export async function skipTask(task: BatchTask, reason: string): Promise<void> {
  try {
    const integration = await getIntegration(task.source);
    await integration.addComment(task.id, `Skipped by ralph-starter auto mode: ${reason}`, {
      project: task.project,
    });
  } catch {
    // Non-critical
  }
}
